#pragma kernel CSMain

struct Ant {
    float2 position;
    float angle;
};

RWTexture2D<float4> trailMap;
RWStructuredBuffer<Ant> antBuffer;
float time;
float sensorAngle;
float sensorScale;
float rotationSpeed;
float moveSpeed;

float repulseScale;
float attractionScale;
float sensorDistance;

int numAnts;
int2 textureSize;

float2 WrapPosition(float2 position)
{
    float xPos = ((position.x + 1111) % 2) - 1;
    float yPos = ((position.y + 1111) % 2) - 1;
    return float2(xPos, yPos);
    
    // return 1 - 2 * abs(frac(position / 2.0 + 0.5) - 0.5);
}
int2 WrapPixel(int2 pixel)
{
    return (pixel + textureSize) % textureSize;
}

int2 PositionToPixel (float2 position)
{
    int2 pixelPos = (position * 0.5f + 0.5f) * textureSize;
    return pixelPos;
}

uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}
float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}
float random01(int id, Ant ant)
{
    return scaleToRange01(hash(ant.position.y + time * textureSize.x + ant.position.x + hash(id.x + time * 100000)));
}


float sense(Ant agent, float sensorAngleOffset) {
    float angle = agent.angle + sensorAngleOffset;
    float2 sensorDir = float2(cos(angle), sin(angle));

    int2 sensorPos = PositionToPixel(agent.position + (sensorDir * sensorDistance));
    int sensorCentreX = (int)sensorPos.x;
    int sensorCentreY = (int)sensorPos.y;

    float attract = 0;
    float repulse = 0;

    // int4 senseWeight = agent.speciesMask * 2 - 1;
    for (int offsetX = -sensorScale; offsetX <= sensorScale; offsetX ++) {
        for (int offsetY = -sensorScale; offsetY <= sensorScale; offsetY ++) {
            int2 pixelPos = WrapPixel(int2(sensorCentreX + offsetX, sensorCentreY + offsetY));
            attract += trailMap[pixelPos].r;
            repulse += trailMap[pixelPos].g;
        }
    }

    return attract * attractionScale - repulse * repulseScale;
}

#define PI 3.14159265358979323846

float fmap(float value, float inMin, float inMax, float outMin, float outMax)
{
    return outMin + ((value - inMin) / (inMax - inMin)) * (outMax - outMin);
}

float RotateTowards(float angle, float target, float maxChange)
{
    float difference = target - angle;
    // Normalize angle to -PI to PI range
    difference = fmod(difference + PI, 2 * PI);
    if (difference < 0)
        difference += 2 * PI;
    difference -= PI;

    // Clamp the difference with the max change
    difference = clamp(difference, -maxChange, maxChange);

    // Add difference to the original angle and normalize again
    float newAngle = angle + difference;
    newAngle = fmod(newAngle + PI, 2 * PI);
    if (newAngle < 0)
        newAngle += 2 * PI;
    newAngle -= PI;

    return newAngle;
}
float RotateTowardsCentre(Ant ant) {
    // The center in normalized coordinates is (0,0)
    float2 centre = float2(0, 0);

    // Compute the direction from the ant to the centre
    float2 toCentre = centre - ant.position;
    float distance = length(toCentre);
    
    // Compute the target angle using atan2, this gives us the angle from the ant to the centre
    float targetAngle = atan2(toCentre.y, toCentre.x);

    float distanceForInwardsPressure = 0.75;
    float inwardsPressure = fmap(distance, distanceForInwardsPressure, 1, 0, 0.1);
    inwardsPressure = clamp(inwardsPressure, 0, 1);
    
    // Use the RotateTowards function to gradually rotate the ant towards the centre
    ant.angle = RotateTowards(ant.angle, targetAngle, inwardsPressure);

    return ant.angle;
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    if (id.x >= numAnts) return;

    Ant ant = antBuffer[id.x];
    float drunkness = trailMap[PositionToPixel(ant.position)].b;
    float idrunkness = 1 - drunkness;
    float leftSensorVal = sense(ant, sensorAngle) + random01(id.x, ant);
    float rightSensorVal = sense(ant, -sensorAngle) + random01(id.x, ant);

    float distanceFromCenter = length(ant.position);
    float iDistanceFromCenter = 1 - distanceFromCenter;

    ant.angle += time * rotationSpeed * (leftSensorVal - rightSensorVal) * idrunkness * distanceFromCenter;// / fmap(drunkness, 0, 1, 1, 5);// ? 1 : 0);
    ant.angle += fmap(random01(id.x + 10, ant), 0, 1, -0.2, 0.2) * rotationSpeed * idrunkness * 0.01;

    ant.angle = RotateTowardsCentre(ant);
    // float randomAngle = 2.0 * PI * random01(float2(time, ant.position.x + ant.position.y));
    // float randomWeight = 0.05; // Tune this parameter to change the amount of randomness
    // ant.angle = lerp(ant.angle, randomAngle, randomWeight);

    
    // Apply movement
    float2 dir = float2(cos(ant.angle), sin(ant.angle));
    ant.position += dir * time * moveSpeed;// * pow(fmap(drunkness, 0, 1, 1, 5), 2);
    
    ant.position = WrapPosition(ant.position);

    antBuffer[id.x] = ant;
}
